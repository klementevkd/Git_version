// Создать очередь, содержащую слова. Удалить из очереди все слова, совпадающие с последним словом.
#include <iostream> 
using namespace std;

struct queue { // структура очереди
	string value; // значение текущего элемента
	queue* next; // указание на следующий элемент очереди
};

void push(queue*& h, queue*& z, string x) { // функция добавление элемента в конец очереди
	queue* r = new queue; // объявляем буфферный элемент
	r->value = x; // сохраняем его значение
	r->next = NULL; // этот элемент встает последним
	if (!h && !z) { // если очередь пуста
		h = z = r; // это и голова и хвост очереди
	}
	else {		z->next = r; // r - следующий хвост
		z = r; // теперь r - хвост
	}
}

string pop(queue*& h, queue*& z) { // функция удаления элемента из очереди
	queue* r = h; // создаем указатель на голову
	string i = h->value; // сохраняем значение головы
	h = h->next; // сдвигаем указатель на следующий элемент
	if (!h) // если удаляем последний элемент из очереди
		z = NULL;
	delete r; // удаляем первый элемент
	return i; // возвращаем значение
}

int main() {
	setlocale(LC_ALL, "RUS"); // подключение русской клавиатуры 
	int n; // объявление переменных 
	string lastword = ""; // строка последнего слова
	string text = ""; // объявление строки
	bool flag = false; // объявление флага
	queue* sell = NULL;// первая очередь
	queue* drill = NULL; // вторая очередь
	cout << "n = "; // ввод количества слов
	cin >> n; // ввод слова
	for (int i = 0; i != n; i++) { // проходим до конца очереди
		cout << "a[" << i << "] = ";
		cin >> text; // ввод очередного элемента
		push(sell, drill, text); // добавление его в конец очереди
		if (i == n - 1) // если это последнее слово
			lastword = text; // то сохраняем его
	}

	cout << "Новая очередь: ";  // вывод новой очереди
	for (int i = 0; i != n; i++) { // проходим до конца очерели 
		text = pop(sell, drill); // извлекаем последнее значение очереди
		if (!(text == lastword)) // если оно не равно последнему слову
			cout << text << " "; // выводим его
	}
	system("pause"); // системная пауза
	return 0; // возвращение 
}